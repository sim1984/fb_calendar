
CREATE EXCEPTION E_MIN_DATE_EXCEEDS 'Минимальная дата превашет максимальную';

SET TERM ^ ;

CREATE PACKAGE DATE_UTILS
AS
BEGIN
  -- генерация последовательности дат
  -- с интервалом 1 день
  PROCEDURE GENERATE_SERIES (
      MIN_DATE DATE,
      MAX_DATE DATE)
  RETURNS (
      BYDATE DATE);

  -- Уставанавливает пометку для даты и её тип
  PROCEDURE SET_DATE_NOTE (
      ADATE     DATE,
      ADAY_TYPE SMALLINT,
      AREMARK   VARCHAR(255));

  -- снимает пометку у даты
  PROCEDURE UNSET_DATE_NOTE (
      ADATE DATE);

  -- возвращает каленадарь
  PROCEDURE GET_CALENDAR (
      MIN_DATE DATE,
      MAX_DATE DATE)
  RETURNS (
      BYDATE   DATE,
      YEAR_OF    SMALLINT,
      MONTH_OF   SMALLINT,
      DAY_OF     SMALLINT,
      WEEKDAY_OF SMALLINT,
      DATE_TYPE  SMALLINT,
      REMARK   VARCHAR(255));

  -- первый день года
  FUNCTION FIRST_DAY_OF_YEAR(AYEAR SMALLINT) RETURNS DATE;

  -- последний день года
  FUNCTION LAST_DAY_OF_YEAR(AYEAR SMALLINT) RETURNS DATE;

  -- возвращает короткое имя дня недели
  FUNCTION GET_WEEKDAY_NAME(AWEEKDAY SMALLINT) RETURNS CHAR(2);

  -- возвращает имя месяца
  FUNCTION GET_MONTH_NAME(AMONTH SMALLINT) RETURNS VARCHAR(10);

  -- возвращает наименование типа даты
  FUNCTION GET_DAY_TYPE_NAME(ADAY_TYPE SMALLINT) RETURNS VARCHAR(11);

  -- заполнение/обновление таблицы каледнадря
  PROCEDURE FILL_CALENDAR (
      MIN_DATE DATE,
      MAX_DATE DATE);
END^



SET TERM ; ^


CREATE TABLE CALENDAR (
    BYDATE      DATE NOT NULL,
    YEAR_OF     SMALLINT NOT NULL,
    MONTH_OF    SMALLINT NOT NULL,
    DAY_OF      SMALLINT NOT NULL,
    WEEKDAY_OF  SMALLINT NOT NULL,
    DATE_TYPE   SMALLINT NOT NULL,
    REMARK      VARCHAR(255)
);


CREATE TABLE CALENDAR_NOTES (
    BYDATE    DATE NOT NULL,
    DAY_TYPE  SMALLINT NOT NULL,
    REMARK    VARCHAR(255)
);


CREATE TABLE HOLIDAYS (
    ID      INTEGER GENERATED BY DEFAULT AS IDENTITY,
    AMONTH  SMALLINT NOT NULL,
    ADAY    SMALLINT NOT NULL,
    REMARK  VARCHAR(255) NOT NULL
);

INSERT INTO HOLIDAYS (ID, AMONTH, ADAY, REMARK)
              VALUES (1, 1, 1, 'Новый год');
INSERT INTO HOLIDAYS (ID, AMONTH, ADAY, REMARK)
              VALUES (2, 1, 7, 'Рождество');
INSERT INTO HOLIDAYS (ID, AMONTH, ADAY, REMARK)
              VALUES (3, 2, 23, 'День защитника отечества');
INSERT INTO HOLIDAYS (ID, AMONTH, ADAY, REMARK)
              VALUES (4, 3, 8, 'Международный женский день');
INSERT INTO HOLIDAYS (ID, AMONTH, ADAY, REMARK)
              VALUES (5, 5, 1, 'Праздник весны и труда');
INSERT INTO HOLIDAYS (ID, AMONTH, ADAY, REMARK)
              VALUES (6, 5, 9, 'День победы');
INSERT INTO HOLIDAYS (ID, AMONTH, ADAY, REMARK)
              VALUES (7, 6, 12, 'День России');
INSERT INTO HOLIDAYS (ID, AMONTH, ADAY, REMARK)
              VALUES (8, 11, 4, 'День народного единства');

COMMIT WORK;


ALTER TABLE HOLIDAYS ADD CONSTRAINT UNQ_HOLIDAYS UNIQUE (AMONTH, ADAY);
ALTER TABLE CALENDAR ADD CONSTRAINT PK_CALENDAR PRIMARY KEY (BYDATE);
ALTER TABLE CALENDAR_NOTES ADD CONSTRAINT PK_CALENDAR_NOTES PRIMARY KEY (BYDATE);
ALTER TABLE HOLIDAYS ADD CONSTRAINT PK_HOLIDAYS PRIMARY KEY (ID);


SET TERM ^ ;

CREATE PACKAGE BODY DATE_UTILS
AS
BEGIN
  -- генерация последовательности дат
  -- с интервалом 1 день
  PROCEDURE GENERATE_SERIES (
      MIN_DATE DATE,
      MAX_DATE DATE)
  RETURNS (
      BYDATE DATE)
  AS
  BEGIN
    IF (MIN_DATE > MAX_DATE) THEN
      EXCEPTION E_MIN_DATE_EXCEEDS;
    BYDATE = MIN_DATE;
    WHILE (BYDATE <= MAX_DATE) DO
    BEGIN
      SUSPEND;
      BYDATE = BYDATE + 1;
    END
  END

  -- Уставанавливает пометку для даты и её тип
  PROCEDURE SET_DATE_NOTE (
      ADATE     DATE,
      ADAY_TYPE SMALLINT,
      AREMARK   VARCHAR(255))
  AS
  BEGIN
    UPDATE OR INSERT INTO CALENDAR_NOTES (BYDATE, DAY_TYPE, REMARK)
    VALUES (:ADATE, :ADAY_TYPE, :AREMARK);

    -- если дата уже есть в календаре обновлем её
    UPDATE CALENDAR
    SET DATE_TYPE = :ADAY_TYPE,
        REMARK = :AREMARK
    WHERE BYDATE = :ADATE
      AND (DATE_TYPE <> :ADAY_TYPE OR REMARK <> :AREMARK);
  END

  -- снимает пометку у даты
  PROCEDURE UNSET_DATE_NOTE (
      ADATE DATE)
  AS
  BEGIN
    DELETE FROM CALENDAR_NOTES
    WHERE BYDATE = :ADATE;

    -- надо вернуть тип даты и примечание по умолчанию
    MERGE INTO CALENDAR
    USING (
      SELECT
          :ADATE AS BYDATE,
          CASE
            WHEN HOLIDAYS.ID IS NOT NULL THEN 2
            WHEN EXTRACT(WEEKDAY FROM :ADATE) IN (0, 6) THEN 1
            ELSE 0
          END AS DATE_TYPE,
          HOLIDAYS.REMARK AS REMARK
      FROM RDB$DATABASE
      LEFT JOIN HOLIDAYS ON
        HOLIDAYS.AMONTH = EXTRACT(MONTH FROM :ADATE) AND
        HOLIDAYS.ADAY = EXTRACT(DAY FROM :ADATE)

    ) S
    ON CALENDAR.BYDATE = S.BYDATE
    WHEN MATCHED THEN
    UPDATE SET
      DATE_TYPE = S.DATE_TYPE,
      REMARK = S.REMARK;
  END

  -- возвращает каленадарь
  PROCEDURE GET_CALENDAR (
      MIN_DATE DATE,
      MAX_DATE DATE)
  RETURNS (
      BYDATE     DATE,
      YEAR_OF    SMALLINT,
      MONTH_OF   SMALLINT,
      DAY_OF     SMALLINT,
      WEEKDAY_OF SMALLINT,
      DATE_TYPE  SMALLINT,
      REMARK     VARCHAR(255))
  AS
  BEGIN
    FOR
      SELECT
          D.BYDATE,
          EXTRACT(YEAR FROM d.BYDATE) AS YEAR_OF,
          EXTRACT(MONTH FROM d.BYDATE) AS MONTH_OF,
          EXTRACT(DAY FROM d.BYDATE) AS DAY_OF,
          EXTRACT(WEEKDAY FROM d.BYDATE) AS WEEKDAY_OF,
          CASE
            WHEN NOTES.DAY_TYPE IS NOT NULL THEN NOTES.DAY_TYPE
            WHEN HOLIDAYS.ID IS NOT NULL THEN 2
            WHEN EXTRACT(WEEKDAY FROM D.BYDATE) IN (0, 6) THEN 1
            ELSE 0
          END AS DATE_TYPE,
          COALESCE(NOTES.REMARK, HOLIDAYS.REMARK) AS REMARK
      FROM DATE_UTILS.GENERATE_SERIES(:MIN_DATE, :MAX_DATE) D
          LEFT JOIN HOLIDAYS
            ON HOLIDAYS.AMONTH = EXTRACT(MONTH FROM D.BYDATE) AND
               HOLIDAYS.ADAY = EXTRACT(DAY FROM D.BYDATE)
          LEFT JOIN CALENDAR_NOTES NOTES
            ON NOTES.BYDATE = D.BYDATE
      INTO BYDATE,
           YEAR_OF,
           MONTH_OF,
           DAY_OF,
           WEEKDAY_OF,
           DATE_TYPE,
           REMARK
    DO
      SUSPEND;
  END

  -- первый день года
  FUNCTION FIRST_DAY_OF_YEAR(AYEAR SMALLINT) RETURNS DATE
  AS
  BEGIN
    RETURN AYEAR || '-01-01';
  END

  -- последний день года
  FUNCTION LAST_DAY_OF_YEAR(AYEAR SMALLINT) RETURNS DATE
  AS
  BEGIN
    RETURN AYEAR || '-12-31';
  END

  -- возвращает короткое имя дня недели
  FUNCTION GET_WEEKDAY_NAME(AWEEKDAY SMALLINT) RETURNS CHAR(2)
  AS
  BEGIN
    RETURN CASE AWEEKDAY
      WHEN 1 THEN 'пн'
      WHEN 2 THEN 'вт'
      WHEN 3 THEN 'ср'
      WHEN 4 THEN 'чт'
      WHEN 5 THEN 'пт'
      WHEN 6 THEN 'сб'
      WHEN 0 THEN 'вс'
    END;
  END

  -- возвращает имя месяца
  FUNCTION GET_MONTH_NAME(AMONTH SMALLINT) RETURNS VARCHAR(10)
  AS
  BEGIN
    RETURN CASE AMONTH
      WHEN 1 THEN 'январь'
      WHEN 2 THEN 'февраль'
      WHEN 3 THEN 'март'
      WHEN 4 THEN 'апрель'
      WHEN 5 THEN 'май'
      WHEN 6 THEN 'июнь'
      WHEN 7 THEN 'июль'
      WHEN 8 THEN 'август'
      WHEN 9 THEN 'сентябрь'
      WHEN 10 THEN 'октябрь'
      WHEN 11 THEN 'ноябрь'
      WHEN 12 THEN 'декабрь'
    END;
  END

  -- возвращает наименование типа даты
  FUNCTION GET_DAY_TYPE_NAME(ADAY_TYPE SMALLINT) RETURNS VARCHAR(11)
  AS
  BEGIN
    RETURN CASE ADAY_TYPE
      WHEN 0 THEN 'Рабочий'
      WHEN 1 THEN 'Выходной'
      WHEN 2 THEN 'Праздничный'
    END;
  END

  -- заполнение/обновление таблицы каледнадря
  PROCEDURE FILL_CALENDAR (
      MIN_DATE DATE,
      MAX_DATE DATE)
  AS
  BEGIN
    MERGE INTO CALENDAR
    USING (
      SELECT
        BYDATE,
        YEAR_OF,
        MONTH_OF,
        DAY_OF,
        WEEKDAY_OF,
        DATE_TYPE,
        REMARK
      FROM DATE_UTILS.GET_CALENDAR(:MIN_DATE, :MAX_DATE)
    ) S
    ON CALENDAR.BYDATE = S.BYDATE
    WHEN NOT MATCHED THEN
    INSERT (
      BYDATE,
      YEAR_OF,
      MONTH_OF,
      DAY_OF,
      WEEKDAY_OF,
      DATE_TYPE,
      REMARK
    )
    VALUES (
      S.BYDATE,
      S.YEAR_OF,
      S.MONTH_OF,
      S.DAY_OF,
      S.WEEKDAY_OF,
      S.DATE_TYPE,
      S.REMARK
    )
    WHEN MATCHED AND
      (CALENDAR.DATE_TYPE <> S.DATE_TYPE OR CALENDAR.REMARK <> S.REMARK) THEN
    UPDATE SET
      DATE_TYPE = S.DATE_TYPE,
      REMARK = S.REMARK;
  END
END^

SET TERM ; ^

COMMENT ON PACKAGE DATE_UTILS IS
'Утилиты для работы с датами и производственным каледарём';

GRANT USAGE ON EXCEPTION E_MIN_DATE_EXCEEDS TO PACKAGE DATE_UTILS;
GRANT SELECT,INSERT,DELETE,UPDATE ON CALENDAR_NOTES TO PACKAGE DATE_UTILS;
GRANT SELECT,INSERT,UPDATE ON CALENDAR TO PACKAGE DATE_UTILS;
GRANT SELECT ON HOLIDAYS TO PACKAGE DATE_UTILS;
GRANT SELECT ON DATE_UTILS TO PACKAGE DATE_UTILS;

